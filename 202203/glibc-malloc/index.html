<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>glibc-malloc源码阅读 - Bing's Blog</title><meta name=keywords content="[Life bbing bing hugo Blog C++ LoveIt]"><meta name=Description content="个人技术博客"><meta property="og:title" content="glibc-malloc源码阅读"><meta property="og:description" content="在上一篇中，我们了解到了mmap的一些性质和基本原理："><meta property="og:type" content="article"><meta property="og:url" content="https://imcbc.cn/202203/glibc-malloc/"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/caibingcheng/resources@main/images/13bOkrO.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-25T11:10:19+08:00"><meta property="article:modified_time" content="2022-03-25T11:10:19+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://cdn.jsdelivr.net/gh/caibingcheng/resources@main/images/13bOkrO.png"><meta name=twitter:title content="glibc-malloc源码阅读"><meta name=twitter:description content="在上一篇中，我们了解到了mmap的一些性质和基本原理："><meta name=application-name content="Bing's Blog"><meta name=apple-mobile-web-app-title content="Bing's Blog"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://imcbc.cn/202203/glibc-malloc/><link rel=prev href=https://imcbc.cn/202203/work-summary-1922/><link rel=next href=https://imcbc.cn/202203/glibc-malloc2/><link rel=stylesheet href=https://fastly.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css><link rel=stylesheet href=https://fastly.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css><link rel=stylesheet href=https://fastly.jsdelivr.net/gh/Albejr/jquery-albe-timeline/templates/simple/style-albe-timeline.css><link rel=stylesheet href=https://fastly.jsdelivr.net/gh/caibingcheng/orlike@client/orlike.min.css><link rel=stylesheet href=/css/custom.css><meta name=google-site-verification content="xy1bCgQPV_H3_o2XD34o2mIByQxmzkV3GPOfhXg_mTM"><meta name=msvalidate.01 content="c81a65b6344571786df543a56c7bbe18"><meta name=baidu-site-verification content="code-WcyzWjgFYo"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"glibc-malloc源码阅读","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/imcbc.cn\/202203\/glibc-malloc\/"},"image":["https:\/\/imcbc.cn\/android-chrome-192x192.png"],"genre":"posts","keywords":"Linux, glibc","wordcount":3387,"url":"https:\/\/imcbc.cn\/202203\/glibc-malloc\/","datePublished":"2022-03-25T11:10:19+08:00","dateModified":"2022-03-25T11:10:19+08:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"Bing","logo":"https:\/\/imcbc.cn\/android-chrome-192x192.png"},"author":{"@type":"Person","name":"bbing"},"description":""}</script></head><body header-desktop=normal header-mobile=normal><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><a href=https://github.com/caibingcheng/ class=github-corner aria-label="View source on GitHub"><svg width="3.5rem" height="3.5rem" viewBox="0 0 250 250" style="fill:#151513;color:#fff;position:absolute;top:0;border:0;left:0;transform:scale(-1,1)" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div class=header-title><a href=/ title="Bing's Blog">Bing's Blog</a></div><div class=menu><div class=menu-inner><div class=dropdown><a href=/posts/ class="menu-item menu-more dropbtn" title><i class='fas fa fa-archive'></i> 归档</a><div class="menu-more-content dropdown-content"><a href=/tags/ title><i class='fas fa fa-tag'></i> 标签 </a><a href=/categories/ title><i class='fas fa fa-th'></i> 分类</a></div></div><a class=menu-item href=/friends/><i class='fas fa fa-users'></i> 友链</a><div class=dropdown><a href=javascript:void(0); class="menu-item menu-more dropbtn" title><i class='fas fa fa-angle-double-down'></i> 更多</a><div class="menu-more-content dropdown-content"><a href=/tools/ title><i class='fas fa fa-cubes'></i> 工具 </a><a href=/about/ title><i class='fas fa fa-address-card'></i> 关于 </a><a href=/timeline/ title><i class='fas fa fa-building'></i> 建站 </a><a href=/index.xml/ title><i class='fas fa fa-rss'></i> RSS</a></div></div><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章内容 id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin"></i></span>
</span><a href=https://travellings.link target=_blank class=menu-item rel=noopener title=开往-友链接力><i class='fas fa-fw fa-subway'></i></a>
<a href=https://rssblog.cn/bbing class=menu-item target=_blank rel=noopener title=RSSBlog><i class='fas fa-fw fa-inbox'></i></a>
<a href=https://www.foreverblog.cn/go.html class=menu-item target=_blank rel=noopener title=穿梭虫洞><i class="fas fa-fw fa-life-ring" title=穿梭虫洞-随机访问十年之约友链博客></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Bing's Blog">Bing's Blog</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章内容 id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin"></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a href=/posts/ class=menu-item title><i class='fas fa fa-archive'></i> 归档</a>
<a href=/tags/ class=menu-item title><i class='fas fa fa-tag'></i> 标签</a>
<a href=/categories/ class=menu-item title><i class='fas fa fa-th'></i> 分类</a>
<a class=menu-item href=/friends/><i class='fas fa fa-users'></i> 友链</a>
<a href=/tools/ class=menu-item title><i class='fas fa fa-cubes'></i> 工具</a>
<a href=/about/ class=menu-item title><i class='fas fa fa-address-card'></i> 关于</a>
<a href=/timeline/ class=menu-item title><i class='fas fa fa-building'></i> 建站</a>
<a href=/index.xml/ class=menu-item title><i class='fas fa fa-rss'></i> RSS</a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class=single-title>glibc-malloc源码阅读<sup>
<a id=reader-button-title title=阅读模式><i class="fa fa-book fa-fw"></i></a></sup></h1><div class=post-meta><div class=post-meta-line></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2022-03-25>2022-03-25</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 3387 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 7 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#概述>概述</a></li><li><a href=#__libc_malloc>__libc_malloc</a><ul><li><a href=#hook>hook</a></li><li><a href=#tcache>tcache</a></li><li><a href=#_int_malloc>_int_malloc</a><ul><li><a href=#第一部分>第一部分</a></li><li><a href=#第二部分>第二部分</a></li><li><a href=#第三部分>第三部分</a></li><li><a href=#第四部分>第四部分</a></li></ul></li><li><a href=#总结>总结</a></li></ul></li></ul></nav></div></div><div class=content id=content><p>在<a href=/202202/glibc-mmap/ rel>上一篇</a>中，我们了解到了<code>mmap</code>的一些性质和基本原理：</p><ol><li>分配的是虚拟内存</li><li>通过红黑树找到目标内存块，并且通过红黑树管理</li><li>分配的内存可能比实际需要的大</li><li>是阻塞的</li><li>会有内存对齐</li></ol><p>本篇将了解到<code>malloc</code>和<code>mmap</code>的关系，以及解答我在<code>mmap</code>学习中产生的一个疑问：<code>mmap</code>会不会导致内存碎片？（因为<code>mmap</code>的内存看起来是被内核维护的红黑树管理了，所以我理解不会存在内存碎片。）</p><h2 id=概述>概述</h2><p>以下是<a href=https://code.woboq.org/userspace/glibc/malloc/malloc.c.html target=_blank rel="noopener noreffer">malloc.c</a>中关于<code>malloc</code>的一小段概述：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>  The main properties of the algorithms are:
</span></span><span class=line><span class=cl>  * For large (&gt;= 512 bytes) requests, it is a pure best-fit allocator,
</span></span><span class=line><span class=cl>    with ties normally decided via FIFO (i.e. least recently used).
</span></span><span class=line><span class=cl>  * For small (&lt;= 64 bytes by default) requests, it is a caching
</span></span><span class=line><span class=cl>    allocator, that maintains pools of quickly recycled chunks.
</span></span><span class=line><span class=cl>  * In between, and for combinations of large and small requests, it does
</span></span><span class=line><span class=cl>    the best it can trying to meet both goals at once.
</span></span><span class=line><span class=cl>  * For very large requests (&gt;= 128KB by default), it relies on system
</span></span><span class=line><span class=cl>    memory mapping facilities, if supported.
</span></span></code></pre></td></tr></table></div></div><p>有些地方可能不理解，先看代码吧～</p><h2 id=__libc_malloc>__libc_malloc</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span>
</span></span><span class=line><span class=cl><span class=nf>__libc_malloc</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>bytes</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>mstate</span> <span class=n>ar_ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=o>*</span><span class=n>victim</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=n>hook</span><span class=p>)</span> <span class=p>(</span><span class=n>size_t</span><span class=p>,</span> <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>=</span> <span class=n>atomic_forced_read</span> <span class=p>(</span><span class=n>__malloc_hook</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>__builtin_expect</span> <span class=p>(</span><span class=n>hook</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=o>*</span><span class=n>hook</span><span class=p>)(</span><span class=n>bytes</span><span class=p>,</span> <span class=n>RETURN_ADDRESS</span> <span class=p>(</span><span class=mi>0</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=cp>#if USE_TCACHE
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=cm>/* int_free also calls request2size, be careful to not pad twice.  */</span>
</span></span><span class=line><span class=cl>  <span class=n>size_t</span> <span class=n>tbytes</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>checked_request2size</span> <span class=p>(</span><span class=n>bytes</span><span class=p>,</span> <span class=n>tbytes</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>size_t</span> <span class=n>tc_idx</span> <span class=o>=</span> <span class=n>csize2tidx</span> <span class=p>(</span><span class=n>tbytes</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>MAYBE_INIT_TCACHE</span> <span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>DIAG_PUSH_NEEDS_COMMENT</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>tc_idx</span> <span class=o>&lt;</span> <span class=n>mp_</span><span class=p>.</span><span class=n>tcache_bins</span>
</span></span><span class=line><span class=cl>      <span class=cm>/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class=cm>/* to appease gcc */</span>
</span></span><span class=line><span class=cl>      <span class=o>&amp;&amp;</span> <span class=n>tcache</span>
</span></span><span class=line><span class=cl>      <span class=o>&amp;&amp;</span> <span class=n>tcache</span><span class=o>-&gt;</span><span class=n>entries</span><span class=p>[</span><span class=n>tc_idx</span><span class=p>]</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>tcache_get</span> <span class=p>(</span><span class=n>tc_idx</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>DIAG_POP_NEEDS_COMMENT</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=k>if</span> <span class=p>(</span><span class=n>SINGLE_THREAD_P</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>victim</span> <span class=o>=</span> <span class=n>_int_malloc</span> <span class=p>(</span><span class=o>&amp;</span><span class=n>main_arena</span><span class=p>,</span> <span class=n>bytes</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>assert</span> <span class=p>(</span><span class=o>!</span><span class=n>victim</span> <span class=o>||</span> <span class=n>chunk_is_mmapped</span> <span class=p>(</span><span class=n>mem2chunk</span> <span class=p>(</span><span class=n>victim</span><span class=p>))</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>              <span class=o>&amp;</span><span class=n>main_arena</span> <span class=o>==</span> <span class=n>arena_for_chunk</span> <span class=p>(</span><span class=n>mem2chunk</span> <span class=p>(</span><span class=n>victim</span><span class=p>)));</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>victim</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>arena_get</span> <span class=p>(</span><span class=n>ar_ptr</span><span class=p>,</span> <span class=n>bytes</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>victim</span> <span class=o>=</span> <span class=n>_int_malloc</span> <span class=p>(</span><span class=n>ar_ptr</span><span class=p>,</span> <span class=n>bytes</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=cm>/* Retry with another arena only if we were able to find a usable arena
</span></span></span><span class=line><span class=cl><span class=cm>     before.  */</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>victim</span> <span class=o>&amp;&amp;</span> <span class=n>ar_ptr</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>LIBC_PROBE</span> <span class=p>(</span><span class=n>memory_malloc_retry</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=n>bytes</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>ar_ptr</span> <span class=o>=</span> <span class=n>arena_get_retry</span> <span class=p>(</span><span class=n>ar_ptr</span><span class=p>,</span> <span class=n>bytes</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>victim</span> <span class=o>=</span> <span class=n>_int_malloc</span> <span class=p>(</span><span class=n>ar_ptr</span><span class=p>,</span> <span class=n>bytes</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>ar_ptr</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>__libc_lock_unlock</span> <span class=p>(</span><span class=n>ar_ptr</span><span class=o>-&gt;</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>assert</span> <span class=p>(</span><span class=o>!</span><span class=n>victim</span> <span class=o>||</span> <span class=n>chunk_is_mmapped</span> <span class=p>(</span><span class=n>mem2chunk</span> <span class=p>(</span><span class=n>victim</span><span class=p>))</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>          <span class=n>ar_ptr</span> <span class=o>==</span> <span class=n>arena_for_chunk</span> <span class=p>(</span><span class=n>mem2chunk</span> <span class=p>(</span><span class=n>victim</span><span class=p>)));</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>victim</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=hook>hook</h3><p>以上第一段是调用<code>hook</code>函数，也就是说<code>malloc</code>默认是提供<code>hook</code>接口的，只要实现了<code>hook</code>接口，<code>malloc</code>就可以变成对应的<code>hook</code>函数。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl>  <span class=kt>void</span> <span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=n>hook</span><span class=p>)</span> <span class=p>(</span><span class=n>size_t</span><span class=p>,</span> <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>=</span> <span class=n>atomic_forced_read</span> <span class=p>(</span><span class=n>__malloc_hook</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>__builtin_expect</span> <span class=p>(</span><span class=n>hook</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=o>*</span><span class=n>hook</span><span class=p>)(</span><span class=n>bytes</span><span class=p>,</span> <span class=n>RETURN_ADDRESS</span> <span class=p>(</span><span class=mi>0</span><span class=p>));</span>
</span></span></code></pre></td></tr></table></div></div><p><code>__malloc_hook</code>的默认值是指向的<code>malloc_hook_ini</code>，如下，<code>malloc_hook_ini</code>会给<code>__malloc_hook</code>赋空，所以<code>malloc_hook_ini</code>可以相当于就是<code>__libc_malloc</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=o>*</span>
</span></span><span class=line><span class=cl><span class=nf>malloc_hook_ini</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>sz</span><span class=p>,</span> <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>caller</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>__malloc_hook</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>ptmalloc_init</span> <span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>__libc_malloc</span> <span class=p>(</span><span class=n>sz</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=tcache>tcache</h3><p>第二部分是<code>tcache</code>，暂且不用过分追究（因为内容比较多，虽然目前<code>malloc</code>可能依赖于<code>tcache</code>，但是即使不学习<code>tcache</code>也不太影响对<code>malloc</code>的理解）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#if USE_TCACHE
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=cm>/* int_free also calls request2size, be careful to not pad twice.  */</span>
</span></span><span class=line><span class=cl>  <span class=n>size_t</span> <span class=n>tbytes</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>checked_request2size</span> <span class=p>(</span><span class=n>bytes</span><span class=p>,</span> <span class=n>tbytes</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>size_t</span> <span class=n>tc_idx</span> <span class=o>=</span> <span class=n>csize2tidx</span> <span class=p>(</span><span class=n>tbytes</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>MAYBE_INIT_TCACHE</span> <span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>DIAG_PUSH_NEEDS_COMMENT</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>tc_idx</span> <span class=o>&lt;</span> <span class=n>mp_</span><span class=p>.</span><span class=n>tcache_bins</span>
</span></span><span class=line><span class=cl>      <span class=cm>/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class=cm>/* to appease gcc */</span>
</span></span><span class=line><span class=cl>      <span class=o>&amp;&amp;</span> <span class=n>tcache</span>
</span></span><span class=line><span class=cl>      <span class=o>&amp;&amp;</span> <span class=n>tcache</span><span class=o>-&gt;</span><span class=n>entries</span><span class=p>[</span><span class=n>tc_idx</span><span class=p>]</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>tcache_get</span> <span class=p>(</span><span class=n>tc_idx</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>DIAG_POP_NEEDS_COMMENT</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></td></tr></table></div></div><p>两个宏如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#define request2size(req)                                         \
</span></span></span><span class=line><span class=cl><span class=cp>  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \
</span></span></span><span class=line><span class=cl><span class=cp>   MINSIZE :                                                      \
</span></span></span><span class=line><span class=cl><span class=cp>   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define checked_request2size(req, sz) \
</span></span></span><span class=line><span class=cl><span class=cp>({                                    \
</span></span></span><span class=line><span class=cl><span class=cp>  (sz) = request2size (req);            \
</span></span></span><span class=line><span class=cl><span class=cp>  if (((sz) &lt; (req))                    \
</span></span></span><span class=line><span class=cl><span class=cp>      || REQUEST_OUT_OF_RANGE (sz)) \
</span></span></span><span class=line><span class=cl><span class=cp>    {                                    \
</span></span></span><span class=line><span class=cl><span class=cp>      __set_errno (ENOMEM);            \
</span></span></span><span class=line><span class=cl><span class=cp>      return 0;                            \
</span></span></span><span class=line><span class=cl><span class=cp>    }                                    \
</span></span></span><span class=line><span class=cl><span class=cp>})
</span></span></span></code></pre></td></tr></table></div></div><p>如上，先是内存对齐，得到<code>tbytes</code>，然后根据<code>tbytes</code>计算出来一个下标<code>tc_idx</code>，然后就可以根据下标去<code>tcache</code>里面找了。</p><p><code>tcache</code>的基本定义如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cm>/* We overlay this structure on the user-data portion of a chunk when
</span></span></span><span class=line><span class=cl><span class=cm>   the chunk is stored in the per-thread cache.  */</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>tcache_entry</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>tcache_entry</span> <span class=o>*</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=cm>/* This field exists to detect double frees.  */</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>tcache_perthread_struct</span> <span class=o>*</span><span class=n>key</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>tcache_entry</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cm>/* There is one of these for each thread, which contains the
</span></span></span><span class=line><span class=cl><span class=cm>   per-thread cache (hence &#34;tcache_perthread_struct&#34;).  Keeping
</span></span></span><span class=line><span class=cl><span class=cm>   overall size low is mildly important.  Note that COUNTS and ENTRIES
</span></span></span><span class=line><span class=cl><span class=cm>   are redundant (we could have just counted the linked list each
</span></span></span><span class=line><span class=cl><span class=cm>   time), this is for performance reasons.  */</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>tcache_perthread_struct</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=n>counts</span><span class=p>[</span><span class=n>TCACHE_MAX_BINS</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=n>tcache_entry</span> <span class=o>*</span><span class=n>entries</span><span class=p>[</span><span class=n>TCACHE_MAX_BINS</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>tcache_perthread_struct</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=n>__thread</span> <span class=kt>bool</span> <span class=n>tcache_shutting_down</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=n>__thread</span> <span class=n>tcache_perthread_struct</span> <span class=o>*</span><span class=n>tcache</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>可以知道几点：</p><ol><li><code>tcache</code>是每个线程维护的</li><li><code>tcache</code>是一个链表结构</li></ol><p>在<code>malloc</code>中，通过<code>tcache_get</code>接口从<code>tcache</code>中获取了一块buffer，实现如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cm>/* Caller must ensure that we know tc_idx is valid and there&#39;s
</span></span></span><span class=line><span class=cl><span class=cm>   available chunks to remove.  */</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=n>__always_inline</span> <span class=kt>void</span> <span class=o>*</span>
</span></span><span class=line><span class=cl><span class=nf>tcache_get</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>tc_idx</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>tcache_entry</span> <span class=o>*</span><span class=n>e</span> <span class=o>=</span> <span class=n>tcache</span><span class=o>-&gt;</span><span class=n>entries</span><span class=p>[</span><span class=n>tc_idx</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=n>assert</span> <span class=p>(</span><span class=n>tc_idx</span> <span class=o>&lt;</span> <span class=n>TCACHE_MAX_BINS</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>assert</span> <span class=p>(</span><span class=n>tcache</span><span class=o>-&gt;</span><span class=n>counts</span><span class=p>[</span><span class=n>tc_idx</span><span class=p>]</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>tcache</span><span class=o>-&gt;</span><span class=n>entries</span><span class=p>[</span><span class=n>tc_idx</span><span class=p>]</span> <span class=o>=</span> <span class=n>e</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=o>--</span><span class=p>(</span><span class=n>tcache</span><span class=o>-&gt;</span><span class=n>counts</span><span class=p>[</span><span class=n>tc_idx</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>  <span class=n>e</span><span class=o>-&gt;</span><span class=n>key</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span> <span class=n>e</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>大概意思是，拿<code>tcache</code>的第<code>tc_idx</code>个作为输出，然后将原本第<code>tc_idx</code>的<code>entry</code>指向当前需要输出的<code>entry</code>的下一个，这意味着<code>tcache</code>里面不同的<code>entry</code>也可能指向同一个，然后再把对应的第<code>tc_idx</code>的<code>count--</code>。</p><p>再看一下和<code>get</code>对应的<code>put</code>操作：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cm>/* Caller must ensure that we know tc_idx is valid and there&#39;s room
</span></span></span><span class=line><span class=cl><span class=cm>   for more chunks.  */</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=n>__always_inline</span> <span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>tcache_put</span> <span class=p>(</span><span class=n>mchunkptr</span> <span class=n>chunk</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>tc_idx</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>tcache_entry</span> <span class=o>*</span><span class=n>e</span> <span class=o>=</span> <span class=p>(</span><span class=n>tcache_entry</span> <span class=o>*</span><span class=p>)</span> <span class=n>chunk2mem</span> <span class=p>(</span><span class=n>chunk</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>assert</span> <span class=p>(</span><span class=n>tc_idx</span> <span class=o>&lt;</span> <span class=n>TCACHE_MAX_BINS</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=cm>/* Mark this chunk as &#34;in the tcache&#34; so the test in _int_free will
</span></span></span><span class=line><span class=cl><span class=cm>     detect a double free.  */</span>
</span></span><span class=line><span class=cl>  <span class=n>e</span><span class=o>-&gt;</span><span class=n>key</span> <span class=o>=</span> <span class=n>tcache</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>e</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>tcache</span><span class=o>-&gt;</span><span class=n>entries</span><span class=p>[</span><span class=n>tc_idx</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=n>tcache</span><span class=o>-&gt;</span><span class=n>entries</span><span class=p>[</span><span class=n>tc_idx</span><span class=p>]</span> <span class=o>=</span> <span class=n>e</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=o>++</span><span class=p>(</span><span class=n>tcache</span><span class=o>-&gt;</span><span class=n>counts</span><span class=p>[</span><span class=n>tc_idx</span><span class=p>]);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>恩！可以和<code>get</code>对应起来了，<code>get</code>的时候第<code>tc_idx</code>的<code>entry</code>被指向了下一个，在<code>put</code>的时候就可以记住下一个的位置，然后<code>put</code>的时候将<code>tc_idx</code>指回去就行了，所以链表又恢复到了原状。</p><p>这里有个疑问：<code>entry</code>的状态是怎么记录的？比如<code>get</code>的时候发送一个<code>entry</code>出去，那么<code>free</code>的时候怎么记得这个<code>buffer</code>的大小/来源等等之类的呢？可以想到一些类比结构，比如：</p><ol><li><code>task_struct</code>和<code>thread_info</code>的内存关系（<a href=/202105/process-ctracon4#%e5%86%85%e6%a0%b8%e6%a0%88 rel>这里</a>）</li><li><code>class</code>中<code>type_info</code>和类的内存关系（<a href=/202107/cpp-class-mem2#%e9%97%ae%e9%a2%981-%e7%b1%bb%e6%98%af%e6%80%8e%e4%b9%88%e6%8c%87%e5%90%91%e8%99%9a%e8%a1%a8%e7%9a%84 rel>这里</a>）</li></ol><p>实际上，<code>tcache entry</code>的“头上”还有一块内存空间，在那里记录了<code>malloc</code>内存的一些状态信息。在<a href=https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#malloc_chunk target=_blank rel="noopener noreffer">这里</a>可以看到详细的内存分布。</p><p>以上，我们大概了解到了<code>malloc</code>以及<code>tcache</code>：</p><ol><li><code>malloc</code>可以从<code>tcache</code>中直接拿到内存</li><li><code>tcache</code>可以用作缓存内存，也就是内存可以不立即交还给系统</li><li><code>tcache</code>相当于是一个内存池，并且由每个线程维护</li><li><code>malloc</code>的内存比实际需要的内存大</li></ol><p>以上默认情况是可以从<code>tcache</code>中获取内存，如果不可以或者里面没有内存呢？</p><h3 id=_int_malloc>_int_malloc</h3><p>如果上述条件不满足，<code>__libc_malloc</code>后续的主要逻辑就是调用<code>_int_malloc</code>函数，如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=n>arena_get</span> <span class=p>(</span><span class=n>ar_ptr</span><span class=p>,</span> <span class=n>bytes</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>victim</span> <span class=o>=</span> <span class=n>_int_malloc</span> <span class=p>(</span><span class=n>ar_ptr</span><span class=p>,</span> <span class=n>bytes</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=第一部分>第一部分</h4><p>第一部分可能调用<code>sysmalloc</code>，其中会使用<code>mmap</code>或者<code>brk</code>分配内存。只有<code>av</code>为空的时候才可能进入这一段，<code>av</code>什么时候可能为空？在线程第一次调用<code>malloc</code>之前，<code>av</code>可能为空。这时候通过系统调用申请一块比较大的内存，然后再执行某种分配，填充到<code>av</code>，所以此后，部分内存可以直接通过<code>av</code>获取，而不需要频繁执行系统调用了。（<code>sysmalloc</code>不是系统调用）</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cm>/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from
</span></span></span><span class=line><span class=cl><span class=cm>    mmap.  */</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>__glibc_unlikely</span> <span class=p>(</span><span class=n>av</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=n>sysmalloc</span> <span class=p>(</span><span class=n>nb</span><span class=p>,</span> <span class=n>av</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>p</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>alloc_perturb</span> <span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=n>bytes</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=第二部分>第二部分</h4><p>第二部分代码很多，只看外部的一点：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>if</span> <span class=p>((</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)</span> <span class=p>(</span><span class=n>nb</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)</span> <span class=p>(</span><span class=n>get_max_fast</span> <span class=p>()))</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>idx</span> <span class=o>=</span> <span class=n>fastbin_index</span> <span class=p>(</span><span class=n>nb</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>mfastbinptr</span> <span class=o>*</span><span class=n>fb</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>fastbin</span> <span class=p>(</span><span class=n>av</span><span class=p>,</span> <span class=n>idx</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>//...
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=n>chunk2mem</span> <span class=p>(</span><span class=n>victim</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>alloc_perturb</span> <span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=n>bytes</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>//...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>只有在申请的内存小于<code>get_max_fast ()</code>的时候才可能进入。类似的，我们可以看到有<code>fastbin</code>这样的结构，和上文中看到的<code>tcache</code>一样，会有专门的表维护<code>fastbin</code>，并且其中储存的是较小的内存。</p><p>从<code>fastbin</code>这中拿到内存后，通过<code>chunk2mem</code>转换成用户可用的内存（实际上就是往高字节取）。</p><h4 id=第三部分>第三部分</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>    If a small request, check regular bin.  Since these &#34;smallbins&#34;
</span></span></span><span class=line><span class=cl><span class=cm>    hold one size each, no searching within bins is necessary.
</span></span></span><span class=line><span class=cl><span class=cm>    (For a large request, we need to wait until unsorted chunks are
</span></span></span><span class=line><span class=cl><span class=cm>    processed to find best fit. But for small ones, fits are exact
</span></span></span><span class=line><span class=cl><span class=cm>    anyway, so we can check now, which is faster.)
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>in_smallbin_range</span> <span class=p>(</span><span class=n>nb</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>idx</span> <span class=o>=</span> <span class=n>smallbin_index</span> <span class=p>(</span><span class=n>nb</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>bin</span> <span class=o>=</span> <span class=n>bin_at</span> <span class=p>(</span><span class=n>av</span><span class=p>,</span> <span class=n>idx</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>//......
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=n>chunk2mem</span> <span class=p>(</span><span class=n>victim</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>alloc_perturb</span> <span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=n>bytes</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>//......
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>    If this is a large request, consolidate fastbins before continuing.
</span></span></span><span class=line><span class=cl><span class=cm>    While it might look excessive to kill all fastbins before
</span></span></span><span class=line><span class=cl><span class=cm>    even seeing if there is space available, this avoids
</span></span></span><span class=line><span class=cl><span class=cm>    fragmentation problems normally associated with fastbins.
</span></span></span><span class=line><span class=cl><span class=cm>    Also, in practice, programs tend to have runs of either small or
</span></span></span><span class=line><span class=cl><span class=cm>    large requests, but less often mixtures, so consolidation is not
</span></span></span><span class=line><span class=cl><span class=cm>    invoked all that often in most programs. And the programs that
</span></span></span><span class=line><span class=cl><span class=cm>    it is called frequently in otherwise tend to fragment.
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=k>else</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>idx</span> <span class=o>=</span> <span class=n>largebin_index</span> <span class=p>(</span><span class=n>nb</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>atomic_load_relaxed</span> <span class=p>(</span><span class=o>&amp;</span><span class=n>av</span><span class=o>-&gt;</span><span class=n>have_fastchunks</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=n>malloc_consolidate</span> <span class=p>(</span><span class=n>av</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>同理，如果<code>fastbin</code>的大小不满足要求，那么就在<code>smallbin</code>里面去找。</p><p>如果<code>smallbin</code>还不满足要求，那么认为需要一个<code>large</code>的内存，这时候会先将<code>fastbin</code>中的小内存合并。其目的是减少内存碎片化（<code>brk</code>内存容易产生碎片，<code>mmap</code>内存不产生碎片，一般情况下只有大内存才会使用<code>mmap</code>申请，比如128KB以上）。</p><p>合并到哪里呢？看<code>malloc_consolidate</code>大概是会合并到一个叫<code>unsorted_bin</code>的<code>bin</code>里面去。</p><h4 id=第四部分>第四部分</h4><p><a href=https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#_int_malloc target=_blank rel="noopener noreffer">源码</a></p><p>（看不懂了！！！）</p><p>遗留问题是（TODO）：</p><ol><li>tcache</li><li>fastbin</li><li>smallbin</li><li>unsorted_bin</li><li>以上如何管理？</li><li>以上什么关系？</li><li>bin是怎么初始化的？</li><li>bin是怎么扩充的，可以扩充吗？</li></ol><h3 id=总结>总结</h3><p>尽管没全部看懂，不过也了解<code>malloc</code>的一些事情：</p><ol><li><code>malloc</code>可以尽可能减少通过系统调用分配内存</li><li><code>malloc</code>可以尽可能减少内存碎片</li><li><code>malloc</code>在用户态管理内存（区别于<code>mmap</code>的<code>rb_tree</code>）</li><li><code>malloc</code>申请内存可能通过“内存池”直接返回，也有可能会通过系统调用返回，一般取决于需要的内存大小</li><li><code>malloc</code>可能存在内存合并的过程</li><li><code>malloc</code>管理的内存数量以及大小是有限的（通过<code>idx</code>的计算方式可以推断出）</li><li><code>malloc</code>管理的内存是按线程区分的，所以多线程情况下不存在阻塞</li><li><code>malloc</code>分配虚拟内存的时候，实际的会比需求的更多（物理内存也会更多，因为需要有存放状态的内存，这时候是已经缺页中断了）</li><li><code>free</code>回收内存不一定直接交还给系统，可能会交由<code>tcache</code>或者<code>bin</code>管理，这是用户态的</li></ol></div><div class=post-footer id=post-footer><div class=orlike-box></div><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2022-03-25</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></div><div class=post-info-more><section><i class="fas fa-fw fa-th"></i>&nbsp;<a href=/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>操作系统</a>,&nbsp;<a href=/categories/glibc/>glibc</a></section><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/linux/>Linux</a>,&nbsp;<a href=/tags/glibc/>glibc</a></section></div><div class=post-nav><a href=/202203/work-summary-1922/ class=prev rel=prev title=这两年工作心态上的一些变化><i class="fas fa-angle-left fa-fw"></i>这两年工作心态上的一些变化</a>
<a href=/202203/glibc-malloc2/ class=next rel=next title=glibc-malloc源码阅读二>glibc-malloc源码阅读二<i class="fas fa-angle-right fa-fw"></i></a></div></div><div id=my-random-posts><div class=loadingThree><span></span>
<span></span>
<span></span>
<span></span>
<span></span></div></div><div id=comments><div id=giscus class=comment></div><script src=https://giscus.app/client.js data-repo=caibingcheng/comment data-repo-id=R_kgDOHgda4w data-category=Announcements data-category-id=DIC_kwDOHgda484CTfDe data-mapping=og:title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=/css/giscus.css data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script><noscript>Please enable JavaScript to view the comments powered by <a href=https://giscus.app/>giscus</a>.</noscript></div></article></div></main><footer class=footer><hr style=opacity:.2><div class=footer-container><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2020 - 2024</span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span><span class=icp-splitter>&nbsp;|&nbsp;</span><br class=icp-br><span class=icp><a href="https://icp.gov.moe/?keyword=20222231" target=_blank>萌ICP备20222231号</a></span></div><div class=footer-line><a href=https://wiki.imcbc.cn target=_blank rel=noopener title="Bing's Wiki">Wiki</a>
&nbsp;|&nbsp;
<a href=https://rssblog.cn target=_blank rel=noopener title=RSSBlog>RSSBlog</a>
&nbsp;|&nbsp;
<a href=https://travellings.link target=_blank rel=noopener title=开往-友链接力>开往-友链接力</a>
&nbsp;|&nbsp;
<a href=https://www.foreverblog.cn/go.html target=_blank>穿梭虫洞</a></div><div class=footer-line><script>var build_date="2024-03-05T21:35:50+08:00"</script>已运行
<span id=run-time></span>
&nbsp;|&nbsp;
构建于
<span id=build-time></span>&nbsp;前</div><div class=footer-line><script async src=https://npm.elemecdn.com/penndu@1.0.0/bsz.js></script>
共计
<span id=busuanzi_value_site_uv></span>&nbsp;访客
&nbsp;|&nbsp;
<span id=busuanzi_value_site_pv></span>&nbsp;访问
&nbsp;|&nbsp;
256K&nbsp;字</div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i>
</a><a id=reader-button class=fixed-button title=阅读模式><i class="fa fa-book fa-fw"></i></a></div><link rel=stylesheet href=https://fastly.jsdelivr.net/npm/lightgallery.js@1.2.0/dist/css/lightgallery.min.css><link rel=stylesheet href=https://fastly.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css><link rel=stylesheet href=https://fastly.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.css><script type=text/javascript src=https://cdn.staticfile.org/jquery/3.6.0/jquery.min.js></script><script type=text/javascript src=https://fastly.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js></script><script type=text/javascript src=https://fastly.jsdelivr.net/npm/autocomplete.js@0.37.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://fastly.jsdelivr.net/npm/algoliasearch@4.2.0/dist/algoliasearch-lite.umd.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=https://fastly.jsdelivr.net/npm/lightgallery.js@1.2.0/dist/js/lightgallery.min.js></script><script type=text/javascript src=https://fastly.jsdelivr.net/npm/lg-thumbnail.js@1.2.0/dist/lg-thumbnail.min.js></script><script type=text/javascript src=https://fastly.jsdelivr.net/npm/lg-zoom.js@1.2.0/dist/lg-zoom.min.js></script><script type=text/javascript src=https://fastly.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js></script><script type=text/javascript src=https://fastly.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js></script><script type=text/javascript src=https://fastly.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js></script><script type=text/javascript src=https://fastly.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.js></script><script type=text/javascript src=https://fastly.jsdelivr.net/npm/katex@0.11.1/dist/contrib/mhchem.min.js></script><script type=text/javascript src=https://fastly.jsdelivr.net/gh/Albejr/jquery-albe-timeline/jquery-albe-timeline.min.js></script><script type=text/javascript src=https://fastly.jsdelivr.net/gh/caibingcheng/orlike@client/orlike.min.js></script><script type=text/javascript src=/js/custom.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:50},comment:{},lightGallery:{actualSize:!1,exThumbImage:"data-thumbnail",hideBarsDelay:2e3,selector:".lightgallery",speed:400,thumbContHeight:80,thumbWidth:80,thumbnail:!0},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{algoliaAppID:"JMTHQS1VUU",algoliaIndex:"blog-bbing",algoliaSearchKey:"0dd43732743475449c844c0d0f21366a",highlightTag:"em",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"algolia"}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>